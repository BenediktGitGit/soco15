\chapter{Technologie}
\label{chapter:Technologie}

\section{Rest-Kommunikation}
Die Kommunikation zwischen den drei konzeptionell festgelegten Komponenten soll ausschließlich über das Programmierparadigma von ReST (Representational State Transfer) von statten gehen. Damit eine Kommunikation als \emph{Restful} bezeichnet werden kann, müssen einige Kriterien erfüllt werden. Ein Rest-Service ist adressierbar, jeder Rest-Endpunkt ist durch eine eindeutige URI gekennzeichnet. Das Format der zurückgelieferten Ressource kann variieren. So können beispielsweise \emph{CSV}, \emph{HTML}, \emph{XML} und \emph{JSON} gleichermaßen von einem Rest-Service bezogen werden. Hierbei ist das Prinzip der Zustandslosigkeit zu beachten, also egal in welchem Format eine Nachricht ankommt, der Informationsgehalt muss äquivalent für gleiche Anfragen sein. Der Kommunikationskanal ist zwar nicht festgeschrieben, ist aber ich aller Regel das HTTP oder das HTTPS. Hierfür gilt es die entsprechenden Empfehlungen für die HTTP-Verbs zu beachten, was vor allem im Punkt Sicherheit wichtig. So bietet eine \emph{GET}-Anfrage weniger Sicherheit als eine \emph{POST}-Anfrage. 

\section{Frameworks}
Zu den nachfolgenden Frameworks und Bibliotheken werden hauptsächlich anwendungsrelevante Funktionalitäten erläutert, da anderen Falls der Rahmen dieser Seminararbeit gesprengt werden würde.

\subsection{Spring Boot}
Spring ist ein unter der Apache Lizenz veröffenlichtes, quelloffenes Java-Framework. Es wird im Folgenden auf zwei besonders markante und wichtige Punkte kurz eingegangen. Beide Verfahren zielen darauf ab, Wiederholungen im Quellcode zu vermeiden sowie eine vereinfachtere Möglichkeit anzubieten, mit weniger Quelltext ans Ziel zu kommen. Diese Thematik wird unter dem Begriff des \emph{Boilerplate Code} oder besser die Vermeidung von \emph{Boilerplate Code} geführt. Spring Boot bietet eine weiterführende Optimierung der Lösungen des Spring Frameworks. So können Anwendungen noch schneller entstehen, da die Art und Weise der Abhängigkeitsverwaltung noch umfassender angewendet, noch zentraler gesteuert wird. So kann z.B. ein Tomcat-Server automatisch eingebunden werden, ohne einen Konfigurationsaufwand in einer integrierten Entwicklungsumgebung auf sich nehmen zu müssen.  

\subsubsection{Dependency Injection}
Die Abhängigkeitsinjektion zielt darauf ab, möglichst wenig Abhängigkeiten zwischen Javaklassen zu konstruieren. Dependency Injection ist ein Entwurfsmuster (Software Pattern) das einen Grundpfeiler von Spring darstellt. Instanzen von Javaklassen müssen demnach ihre Abhängigkeitsinformationen durch einen Aufruf von Methoden einer externen Instanz zugewiesen bekommen. Deshalb wird dieser Vorgang als Injektion bezeichnet. Es werden drei verschiedene Arten von Abhängigkeitsinjektionen unterschieden. \emph{Inversion of Control} (IoC), die Konstruktorinjektion sowie die Setterinjektion. Spring implementiert beispielsweise einen sogenannten IoC-Container. Die darin enthaltenen Objekte verweisen explizit auf Abhängigkeiten, woraus sogenannte \emph{Java-Beans} konstruiert werden. Dies sind Klassen, die einer bestimmten Spezifikation genügen, die hier nicht erklärt wird. Spring bemüht sich im Grunde darum, \emph{Best-Pratices} der Softwareentwicklung im Javaumfeld umzusetzen und den Entwickler hierbei zu unterstützen. Nähers zum Thema Spring kann z.B. unter dem https://spring.io/ nachgelesen werden.

\subsubsection{Annoationen}
Diese sind äußerlich leicht zu erkennen. Sie beginnen mit einem \emph{@}-Zeichen und können Methoden sowie Klassen gleichermaßen kennzeichnen. Annotationen sind Schnittstellen (Interfaces), die grob in zwei Arten unterteilt werden können. Zum einen diejenigen, die während der Kompilierzeit ausgeführt werden und anschließend nicht mehr benötigt werden, wie beispielsweise die \emph{@Override}-Annotation für die Implementierung von Methoden abstrakter Klassen. Die zweite Art ist auch während der Laufzeit noch von Bedeutung, so z.B. die \emph{@Autowired}-Annotation. Diese gibt explizit an, dass eine Klasse per Dependency-Injection in die Programmlogik integriert werden soll. 

\subsection{Javascript Bibliothek - C3js}
Die Auswahl einer geeigneten Javascript-Bibliothek ist nicht leicht. Es gibt zahlreiche gut umgesetzte Lösungen im Umlauf, welche in unterschiedliche Bereichen jeweils Vor - und Nachteile bieten. \emph{C3js} ist relativ schlank und verzichtet auf einige Zusatzkomponenten. Die Basis für C3 ist die \emph{D3js} Bibliothek, deren Diagramme meist einen höheren Grad an visuellen Extravaganzen umsetzt oder auf spezielle Einsatzgebiete eingeht. D3js eignet sich daher eher für ausgefallenere Diagramme, C3js wurde aus Performance-Gründen gewählt und weil die angebotenen Funktionen den gewünschten Informationsgehalt entsprechend wiederspiegeln können.   

\subsection{CSS Bootstrap}
Das Bootstrap Framework ist eine freie und sehr umfangreiche Bibliothek, die Komponenten und Funktionalitäten bereitstellt, die sich an den neuesten Webdesign-Kriterien orientiert. Sie wird unter der MIT-Lizenz veröffentlicht und unterstützt die bekanntesten Browser. Die Visualisierung profitiert stark von der Möglichkeit, das HTML-Gerüst dynamisch an verschiedene Displaygrößen anzupassen (Responsive Design). 

\section{Apache Maven}
Die benötigten Frameworks können auf verschiedene Wege eingebunden werden. Die Softwarepakete können per Hand heruntergeladen und in den entsprechenden Verzeichnispfad kopiert werden, was allerdings bei größeren Projekten hinsichtlicher der Übersicht und Verwaltbarkeit problematisch ist. Ein besserer Ansatz ist es ein Build-Tool wie Apache Maven zu verwenden, was auch für diese Anwendung eingesetzt wurde. Alternative Build-Tools sind z.B. Apache Ant und Gradle.\\
Zentraler Beschreibungspunkt, der das Projekt benötigter Abhängigkeiten und Build-Prozesse ist die POM.xml. POM steht dabei für \emph{Projekt Object Model}.
Die Softwarepakte heißten im Maven-Jargon \emph{Dependencies}, also Abhängigkeiten. Dependencies werden in \emph{Repositories} verwaltet. Es gibt zwei Arten, \emph{local} und \emph{remote} Repositories.   
Die lokale Datenhaltungskomponente stellt eine exakte Kopie aller heruntergeladenen Dependencies sowie deren Verzeichnisstruktur, von rechnerfernen Repositories dar. 